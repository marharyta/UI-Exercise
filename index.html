<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="description" content="Exercise">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=no">
  <base href="/">
  <title>UI Exercise</title>
  <!-- inject:css -->
  <link rel="stylesheet" href="/dist/css/main.css">
  <!-- endinject -->
</head>
<body ng-app="uiApp">
  <button id="start">Start</button>
  <button id="stop">Stop</button>
  <div ui-view></div>
  <!-- bower:js -->
  <script src="bower_components/angular/angular.js"></script>
  <script src="bower_components/angular-ui-router/release/angular-ui-router.js"></script>
  <!-- endbower -->
  <!-- inject:js -->
  <script src="/dist/scripts/app.js"></script>
  <!-- endinject -->

  <!--<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.4.0/d3.min.js"></script>-->
  <script type="text/javascript" src="./d3.min.js"></script>
  <!--<script type="text/javascript" src="./generator.js"></script>-->

  <script type="text/javascript">
  
  /***
  
    This is a demo of space formula 1
    You have to bet on one of five rockets that will eventually make it to the orbit.
    rate 1:10m skaling
    atmosphere is 500km => 500km = 500 *1000m  => 500 000px

  ***/

  //universe model variables
  //distance of universe
  const h = 30000;
  //width of universe
  const w = 1200;
  //rocker size (or car-rocket)
  const rocketHeight = 50;
  //distance they have to fly to reach the orbit
  const distanceToFly = 2000; //km to fly for the rocker
  const universeWidth = 1200;

  //atmosphere heights
  const tropopauzeHeight = 1200;
  const stratopauzeHeight = 4500;
  const mesopauzeHeight = 8500;
  const thermopauzeHeight = 20000;
  const ionosfeerHeight = 30000;

  //create svg element
  const svg = d3.select("body").append("svg");

  svg 
    .attr("width", 900)
    .attr("height", 600)
    .attr("preserveAspectRatio", "xMidYMin "+ "slice")
    .attr("viewBox", " " + 0 + " "+ 29900 + " " + w + " " + h+ " ")
    .attr("viewBox", " " + 0 + " "+ ((h-rocketHeight)- 40) + " " + w + " " + h+ " ");

  //create defs for extra elements

  var defs = svg.append("defs");

  var skyGradient = defs
    .append("linearGradient")
    .attr("id", "skyGradient")
    .attr("x1", "0.5")
    .attr("x2", "0.5")
    .attr("y1", "1")
    .attr("y2", "0.5");

  skyGradient
    .append("stop") 
    .attr("offset", "0%")
    .attr("stop-color", "lightblue");
    
  skyGradient
    .append("stop")
    .attr("offset", "75%")
    .attr("stop-color", "#213B63");

  skyGradient
    .append("stop")
    .attr("offset", "100%")
    .attr("stop-color", "#122036");

  var ozoneLayerGradient = defs
    .append("linearGradient")
    .attr("id", "ozoneLayerGradient")
    .attr("x1", "0.5")
    .attr("x2", "0.5")
    .attr("y1", "1")
    .attr("y2", "0");

  ozoneLayerGradient
    .append("stop") 
    .attr("offset", "0%")
    .attr("stop-color", "rgba(87,199,167, 0.01)"); //rgb(87,199,167) rgb(121,210167)

  ozoneLayerGradient
    .append("stop") 
    .attr("offset", "50%")
    .attr("stop-color", "rgba(87,199,167, 0.9)");
    
  ozoneLayerGradient
    .append("stop")
    .attr("offset", "100%")
    .attr("stop-color", "rgba(87,199,167, 0.01)");

  //end of defs

  const mainGroup = svg.append("g");

  //background sky 
  const backgroundSky = mainGroup
    .append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("height", h)
    .attr("width", w )
    .attr("fill", "url(#skyGradient)");

  
  //atmosphere layers

  const tropopauze = mainGroup.append("g"); //12 km => 12 * 1000m => 120 00m/100 => 1200px
  const stratopauze = mainGroup.append("g"); //45 km => 45 000m => 4500px
  const mesopauze = mainGroup.append("g"); //85 km => 85 000m => 8500px
  const thermopauze = mainGroup.append("g"); //20 0km > 200 0 00 = 20000px
  const ionosfeer = mainGroup.append("g"); //500km

  tropopauze
    .attr("id", "tropopauze")
    .attr("transform", "translate(0," + (h-tropopauzeHeight) +")")
    .append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("height", tropopauzeHeight)
    .attr("width", w)
    .attr("fill", "transparent");


  stratopauze
    .attr("id", "stratopauze")
    .attr("transform", "translate(0," + (h-stratopauzeHeight) +")")
    .append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("height", stratopauzeHeight-tropopauzeHeight)
    .attr("width", w)
    .attr("fill", "transparent");

  mesopauze
    .attr("id", "mesopauze")
    .attr("transform", "translate(0," + (h-mesopauzeHeight) +")")
    .append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("height", mesopauzeHeight - stratopauzeHeight)
    .attr("width", w)
    .attr("fill", "transparent");

  thermopauze
    .attr("id", "thermopauze")
    .attr("transform", "translate(0," + (h-thermopauzeHeight) +")")
    .append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("height", thermopauzeHeight - mesopauzeHeight)
    .attr("width", w )
    .attr("fill", "transparent");

  ionosfeer
    .attr("id", "ionosfeer")
    .attr("transform", "translate(0," + (h-ionosfeerHeight) +")")
    .append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("height", ionosfeerHeight - thermopauzeHeight)
    .attr("width", w)
    .attr("fill", "transparent");


  //checkpoints

  tropopauze
    .append("text")
    .attr("x",20)
    .attr("y",0)
    .text("Troposphere");

  stratopauze
    .append("text")
    .attr("x",20)
    .attr("y",0)
    .text("Stratosphere");

  mesopauze
    .append("text")
    .attr("x",20)
    .attr("y",0)
    .text("Mesosphere");

  thermopauze
    .append("text")
    .attr("x",20)
    .attr("y",0)
    .text("Thermosphere");

  ionosfeer
    .append("text")
    .attr("x",20)
    .attr("y",0)
    .text("Ionosphere");

  mainGroup
    .append("text")
    .attr("x",20)
    .attr("y", h-1200)
    .text("1200");

  mainGroup
    .append("text")
    .attr("x",20)
    .attr("y", h-4500)
    .text("4500");

  mainGroup
    .append("text")
    .attr("x",20)
    .attr("y", h-3000)
    .text("3000");

  mainGroup
    .append("text")
    .attr("x",20)
    .attr("y", h-2000)
    .text("2000");

  
  //ozone layer
  const ozoneLayer = stratopauze.append("g"); // 20-30km from earth => 20 000m => 2000
    
  ozoneLayer
    .attr("id", "ozoneLayer")
    .attr("transform", "translate(0," + 1500 +")")
    .append("rect")
    .attr("x", 0)
    .attr("y", 0)
    .attr("height", 1000)
    .attr("width", w)
    .attr("fill", "url(#ozoneLayerGradient)");

  //stars
  let dataset = [];
  const starsGroup = mainGroup.append("g");

  function generateStarsIonosphere(num){
    let arr = [];
    for(var i = 0; i <= num; i++){
      arr.push(3);
    }
    return arr;
  }

  function randmizeStarPosition(){
    let width = 1200;
    let w = Math.floor(Math.random() * width ) + 1;
    let h = Math.floor(Math.random() * (ionosfeerHeight - thermopauzeHeight)) + 1;
    return [w, h];
  }

  dataset = generateStarsIonosphere(500);
  let stars = starsGroup.selectAll("circle")
    .data(dataset)
    .enter()
    .append("circle")
    .attr("cx", function(d, i) {
      return randmizeStarPosition()[0];
    })
    .attr("cy", function(){
      return randmizeStarPosition()[1];
    })
    .attr("r", function(d) {
      return d;
    })
    .attr("fill", "white");

  
  function Rocket(el, accStart) {
    this.element = el;
    this.flying = true;
    this.maxDistance = h-rocketHeight;
    this.maxVelocity = 100;
    this.state = {
      yCoord: 0,
      timestamp: 0,
      accelaration: accStart,
      velocity: 0,
      finish: false
    };
  }
 
  Rocket.prototype.recalculateState = function (deltaTime) {
        //vNext = vta*dt
    if(this.state.finish === false){
      var nextVelocity = this.state.velocity + this.state.accelaration * deltaTime;
      var nextAccelaration = this.state.accelaration;
      var yCoord = this.state.yCoord + this.state.velocity*deltaTime;
      var finish = yCoord > this.maxDistance;

      if (nextVelocity > this.maxVelocity) {
        nextVelocity = this.maxVelocity;
        nextAccelaration = 0;
      }

      if(yCoord >= this.maxDistance){
        console.log("ycoord",yCoord);
        this.state.finish = true;
        yCoord = 30000;
      }

      var newState = {
        yCoord: yCoord,
        finish: finish,
        timestamp: this.state.timestamp + deltaTime,
        accelaration: nextAccelaration,
        velocity: nextVelocity
      };
      this.state = newState;
    }
      
  
    
  };

  function drawRocket( gap, width, height, yPos, xPos, speed, stopHeight, driver, color, distanceToFly){
    
    rocketPic = mainGroup
      .append("rect")
      .attr("class", "rocket")
      .attr("x", w/2 - gap)
      .attr("y", h-rocketHeight)
      .attr("width", 20)
      .attr("height", rocketHeight);

    rocketPic = mainGroup
      .append("rect")
      .attr("class", "rocket2")
      .attr("x", w/2 - (gap*2))
      .attr("y", h-rocketHeight)
      .attr("width", 20)
      .attr("height", rocketHeight);

    rocketPic = mainGroup
      .append("rect")
      .attr("class", "rocket3")
      .attr("x", w/2 + (gap*2))
      .attr("y", h-rocketHeight)
      .attr("width", 20)
      .attr("height", rocketHeight);
  }
  
  function randomlyGenerateDistance(){
    return Math.floor((Math.random() * 20000) + 1000);
  }

  function randomlyGenerateDuration(){
    return Math.floor((Math.random() * 6000) + 1000);
  }

  var rocketArr = [];
  var rockets = rocketArr;
  var yPos;
  var start = null;
  var starttime;



  var random = randomlyGenerateDistance();
  rocketArr.push(drawRocket(10+2*100,0,0,0,0, 0,0,0,0,random));

  var timeFix;
  var starttime;
       
  function moveit(timestamp, el, dist, duration){
        var elm = el.element;
        //if browser doesn't support requestAnimationFrame, generate our own timestamp using Date:
        
        //starting point
        var timestamp = timestamp;

        //runtine of the flight
        var runtime = timestamp - starttime;
        //progress of steps

        var progress = runtime / duration;

      // use state here
      // ....



      // recalculate state based on delta time in the end of function
      var deltaTime = timeFix === undefined ? 0 : timestamp - timeFix;

      //el.recalculateState(deltaTime);
      el.recalculateState( deltaTime);

      console.log(el);
      //state = nextState;

      timeFix = timestamp;
        var timestamp = timestamp || new Date().getTime();
        var runtime = timestamp - starttime;
        var progress = runtime / duration;
        progress = Math.min(progress, 1);
        var calculatedRocketPosition = h-(dist*progress)-rocketHeight;

        var yCoord = el.state.yCoord;
        //svg.attr("viewBox", " " + 0 + " "+ calculatedRocketPosition + " " + w + " " +  h+ " ");
        //elm.attr("y", calculatedRocketPosition + rocketHeight);
        elm.attr("y", yCoord - rocketHeight);

        
        if (runtime < duration){ // if duration not met yet
            requestAnimationFrame(function(timestamp){ // call requestAnimationFrame again with parameters
                moveit(timestamp, el, dist, duration);
            });
        }
    }
     
    function moveSky(timestamp, el, dist, duration){
        var elm = el.element;
        //if browser doesn't support requestAnimationFrame, generate our own timestamp using Date:
        
        //starting point
        var timestamp = timestamp;

        //runtine of the flight
        var runtime = timestamp - starttime;
        //progress of steps

        var progress = runtime / duration;

      // use state here
      // ....


      // recalculate state based on delta time in the end of function
      var deltaTime = timeFix === undefined ? 0 : timestamp - timeFix;

      //el.recalculateState(deltaTime);
      el.recalculateState( deltaTime);

      console.log(el.state);
      //state = nextState;

      timeFix = timestamp;
        var timestamp = timestamp || new Date().getTime();
        var runtime = timestamp - starttime;
        var progress = runtime / duration;
        progress = Math.min(progress, 1);
        var calculatedRocketPosition = h-(dist*progress)-rocketHeight;

        var yCoord = el.state.yCoord;
        //svg.attr("viewBox", " " + 0 + " "+ calculatedRocketPosition + " " + w + " " +  h+ " ");
        //elm.attr("y", calculatedRocketPosition + rocketHeight);
      //if browser doesn't support requestAnimationFrame, generate our own timestamp using Date:
       /* var timestamp = timestamp || new Date().getTime();
        var runtime = timestamp - starttime;
        var progress = runtime / duration;
        progress = Math.min(progress, 1);
        var calculatedRocketPosition = h-(dist*progress)-rocketHeight;*/

        //svg.attr("viewBox", " " + 0 + " "+ calculatedRocketPosition + " " + w + " " +  h+ " ");
        //el.attr("y", calculatedRocketPosition + rocketHeight);
        //yCoord
        svg.attr("viewBox", " " + 0 + " "+ yCoord + " " + w + " " +  h+ " ");
        
        if (runtime < duration){ // if duration not met yet
            requestAnimationFrame(function(timestamp){ // call requestAnimationFrame again with parameters
                moveSky(timestamp, el, dist, duration);
            });
        }
    }
   

  function launchRockets(){

    rocketFly  = window.requestAnimationFrame(function(timestamp){
      starttime = timestamp;
      var rocket1 =  d3.select(".rocket");
      var rocket2 = d3.select(".rocket2");
      var obj1 = {
        el: rocket1,
        dist: 27000,
        duration: 7000
      };
      var obj2 = {
        el: rocket2,
        dist: 30000,
        duration: 7000
      };

      var testAr = [];
      testAr.push(obj1);
      testAr.push(obj2);
      
      var firstRocket = d3.selectAll(".rocket");
      //step1(timestamp, testAr, 27000, 7000);
      //step1(timestamp, testAr, 30000, 8000);

      var rocketA = new Rocket(rocket1, 2);
      var rocketB = new Rocket(rocket2, 90);
      requestAnimationFrame(function(timestamp){
          starttime = timestamp || new Date().getTime(); //if browser doesn't support requestAnimationFrame, generate our own timestamp using Date
          //moveit(timestamp, adiv, 400, 2000); 
          moveSky(timestamp, rocketA, 2000, 7000);
          moveit(timestamp, rocketA, 2000, 7000);
          //moveit(timestamp, rocketB, 27000, 8000);

      });

       
    });
    
  }



  document.getElementById("start").addEventListener("click", function() {
      launchRockets();
  });

  document.getElementById("stop").addEventListener("click", function() {
    cancelAnimationFrame(rocketFly);
  });

  

  /*function followRocket (yOfRocket, yOfViewPOrt, speedOfFlight, hOfFlight, durationOfFlight){

    durationOfFlight = 20000;
    svg 
      .transition()
    .duration(durationOfFlight)
    .attr("viewBox", " " + 0 + " "+ (h-distanceOfFlight-rocketHeight) + " " + w + " " + h + " ");

    d3.selectAll(".rocket")
      .transition()
      .duration(durationOfFlight)
      .attr("y", h - distanceOfFlight);

  }*/

  
  //followRocket (0,0, 200, 10000, 0);

  /*function drawStarsAtYPosition( YPosition){
    dataset = generateStarsIonosphere(500);
    function calculateStarPosition(){
      let width = Math.floor(Math.random() * w) + 1;
      let height = Math.floor(Math.random() * YPosition+40) + YPosition-40;
      return [width, height];
    }

    let stars = starsGroup.selectAll("circle")
                .data(dataset)
                .enter()
                .append("circle")
                .attr("cx", function(d, i) {
              return calculateStarPosition()[0];
          })
            .attr("cy", function(){
              return calculateStarPosition()[1];
            })
          .attr("r", function(d) {
                  return d;
          })
          //style
          .attr("fill", "white");

  }*/
  
  /*function launchRocket(yPosition, xPosition){
    var yPos = yPosition;
    var start = null;
    var rocketFly;

    function step(timestamp) {
      if (!start) start = timestamp;
      var progress = timestamp - start;
      
      yPos = progress;
      svg.attr("viewBox", " " + 0 + " "+ (distance-yPos-carSize) + " " + width + " " +  distance + " ");
     
      d3.selectAll(".rocket").attr("y", (distance-yPos));
     

      if (yPos < (30000-carSize)) {
        rocketFly = window.requestAnimationFrame(step);
      }

    }

    window.requestAnimationFrame(step);
    document.getElementById("stop").addEventListener("click", function() {
      cancelAnimationFrame(rocketFly);
    });
  }*/


  
  /*
    function launchRocket(timestamp, yPosition, xPosition){
    function step(timestamp) {
      if (!start) start = timestamp;

      var progress = timestamp - start;

      svg.attr("viewBox", " " + (xPosition- rocketHeight) + " "+ (h-yPosition-rocketHeight) + " " + w + " " + h + " ");
     
      d3.selectAll(".rocket").attr("y", (h-yPosition));
      d3.selectAll(".rocket").attr("x", (h-xPosition));

      if (progress < (30000-rocketHeight)) {
        window.requestAnimationFrame(step);
      } else if (progress >= (30000-rocketHeight)){
        cancelAnimationFrame(step);
      }
    }

    window.requestAnimationFrame(step);
  }

  var start = null;

var element = document.getElementById("SomeElementYouWantToAnimate");
element.style.position = 'absolute';

function step(timestamp) {
  if (!start) start = timestamp;
  var progress = timestamp - start;
  element.style.left = Math.min(progress/10, 200) + "px";
  if (progress < 2000) {
    window.requestAnimationFrame(step);
  }
}

window.requestAnimationFrame(step);




    function step(timestamp, rocketObj, duration) {
      var timestamp = timestamp;
      
      var progress = runtime / duration;
      progress = Math.min(progress, 1);
      if (!start) start = timestamp;
      //var progress = timestamp - start;
      
      yPos = progress;
      svg.attr("viewBox", " " + 0 + " "+ (h-yPos-rocketHeight) + " " + w + " " +  h+ " ");
     
      d3.selectAll(".rocket").attr("y", (h-yPos));

      if (yPos < (30000-rocketHeight)) {
        rocketFly = window.requestAnimationFrame(step);
      }

      if (runtime < duration){ // if duration not met yet
          window.requestAnimationFrame(function(timestamp){ // call requestAnimationFrame again with parameters
              //moveit(timestamp, el, dist, duration)
              step(timestamp, rocketObj, duration);
          });
      }

    }

    //window.requestAnimationFrame(step);

    window.requestAnimationFrame(function(timestamp){
        starttime = timestamp || new Date().getTime(); 
        //if browser doesn't support requestAnimationFrame, generate our own timestamp using Date
        moveit(timestamp, adiv, 400, 2000); // 400px over 1 second
    });
    
  }


  

  document.getElementById("start").addEventListener("click", function() {
    launchRocket(0, 5000, 200);
  });

  document.getElementById("stop").addEventListener("click", function() {
    cancelAnimationFrame(step);
  });
  */

  
  </script>
</body>
</html>
